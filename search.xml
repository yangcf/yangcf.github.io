<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springclould整合thymeleaf的坑]]></title>
    <url>%2F2019%2F04%2F23%2Fspringclould%E6%95%B4%E5%90%88thymeleaf%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[thymeleaf是spring官方推崇的模板引擎，下面说一说如何配置 1 添加依赖如果是多模块项目最好放到顶层模块中。123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring4&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.22&lt;/version&gt;&lt;/dependency&gt; 2 配置文件中添加配置 3 目录结构 4 测试调用代码：1234567@Controllerpublic class UserLoginController &#123; @RequestMapping(value = "/",method = RequestMethod.GET) public String login()&#123; return "home"; &#125;&#125; 页面：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org" &gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form class="form-signin" role="form" th:action="@&#123;/user/login&#125;" th:method="post"&gt; &lt;input type="text" class="form-control" placeholder="用户名" required="required" name="userName" /&gt; &lt;input type="password" class="form-control" placeholder="密码" required="required" name="password" /&gt; &lt;button class="btn btn-lg btn-warning btn-block" type="submit"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 一切正常的话就可以用了，刚开始怎么都不能跳转页面，最后终于发现是没有引用nekohtml依赖，弄了俩小时。。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven依赖管理]]></title>
    <url>%2F2019%2F04%2F20%2FMaven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[使用Maven管理项目依赖的一大好处就是能够方便的进行依赖版本管理，但是dependencyManagement和dependencies的概念有点混淆，今天把它弄清楚了，记录一下。 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在dependencyManagement中的依赖不会被子模块继承，仅仅是为了进行版本管理，子模块需要引入groupId和artifactId，如果也引入了version则以子模块为主，类似重写的概念。123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在主模块dependencies下的依赖会直接被子模块继承，如果你的子模块需要依赖一个公共的库可以加在这里方便管理。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>小常识</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boolean源码解析]]></title>
    <url>%2F2018%2F12%2F21%2FBoolean%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[下面我们来学习Boolean。1public final class Boolean implements java.io.Serializable,Comparable&lt;Boolean&gt; 被final修饰，不会被继承，内部变量也会默认不可继承。实现了Comparable,具有比较方法：1234//相等返回0，不等X为ture返回1，否则返回-1public static int compare(boolean x, boolean y) &#123; return (x == y) ? 0 : (x ? 1 : -1); &#125; 将最常用的值加入常量池：12public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false); 有一个有意思的地方，true和false的哈希码是固定的：123public static int hashCode(boolean value) &#123; return value ? 1231 : 1237; &#125; 因为这个原因，对boolean参数类型的equals方法做了特殊处理：1234567//哈哈，这帮人机智啊public boolean equals(Object obj) &#123; if (obj instanceof Boolean) &#123; return value == ((Boolean)obj).booleanValue(); &#125; return false; &#125; 有一个奇葩方法：12345678public static boolean getBoolean(String name) &#123; boolean result = false; try &#123; result = parseBoolean(System.getProperty(name)); &#125; catch (IllegalArgumentException | NullPointerException e) &#123; &#125; return result; &#125; 研究了一会发现他没什么用…请知道应用场景的告诉我（如果说用来读配置文件就算了） 12345678910//这个名字挺有意思，快用这些东西代替 &amp;&amp; 操作吧，1.8后才有哦public static boolean logicalAnd(boolean a, boolean b) &#123; return a &amp;&amp; b; &#125;public static boolean logicalOr(boolean a, boolean b) &#123; return a || b;&#125;public static boolean logicalXor(boolean a, boolean b) &#123; return a ^ b;&#125; 12345678910111213//平时用的最多的应该就是这个了public static Boolean valueOf(String s) &#123; return parseBoolean(s) ? TRUE : FALSE; &#125;public static boolean parseBoolean(String s) &#123; return ((s != null) &amp;&amp; s.equalsIgnoreCase("true")); &#125;public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125; 好了，这个类很简单，咱们快速进入下一个Byte的学习。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer & StringBuilder源码解析]]></title>
    <url>%2F2018%2F12%2F03%2FStringBuffer%26StringBuilder%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[现在我们继续来学习StringBuffer和StringBuilder，之所以把他们放在一起，是因为他们有很多共性，没有必要分开来学习。他们都属于String的衍生物,他们和String最大的区别在于不是字符串常量。 我们都知道当新建一个String对象的时候，会创建一个字符串常量，并且这个对象是不可修改的，在进行一些操作时容易造成内存泄漏，StringBuilder的出现解决了这个问题。下面我们先来看看StringBuilder。 继承了AbstractStringBuilder和String相比少了Comparable接口，这意味着没有他没有compareTo方法。1public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence 下面看一下构造方法，咱们只看一个有代表性的12345@Override public StringBuilder append(CharSequence s) &#123; super.append(s); return this; &#125; 本质上都是利用了super.append()方法，源码如下：12345678910111213141516171819202122232425262728293031323334@Override public AbstractStringBuilder append(CharSequence s) &#123; if (s == null) return appendNull(); if (s instanceof String) return this.append((String)s); if (s instanceof AbstractStringBuilder) return this.append((AbstractStringBuilder)s); return this.append(s, 0, s.length()); &#125;//instanceof String//没什么特别的地方，简单易懂，因为AbstractStringBuilder也实现了CharSequence所以迁移起来非常方便 public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this; &#125;//instanceof AbstractStringBuilder AbstractStringBuilder append(AbstractStringBuilder asb) &#123; if (asb == null) return appendNull(); int len = asb.length(); ensureCapacityInternal(count + len); asb.getChars(0, len, value, count); count += len; return this; &#125; It’s over.真的没什么东西可说了，和String对比看一下马上就明白了。无非就是多了insert()方法。 StringBuffer和StringBuilder几乎一样！！！ 有一点区别，StringBuilder是线程安全的，看一看到凡是涉及到对象操作的时候StringBuffer都是下面这个画风：123456@Override public synchronized void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) &#123; super.getChars(srcBegin, srcEnd, dst, dstBegin); &#125; 利用synchronized来实现方发锁，实现线程安全，几乎所有参数为StringBuffer的方法都会加上这个关键字。对于这个关键字的使用，我的另一篇博文中有过讲解。 好的，就到这了，本文浅尝辄止，想要深入研究的小伙伴要自己努力了！ 另外，强烈建议自己分别用String，StringBuffer和StringBuilder创建对象，看看有什么不同，注意对比地址和哈希码，很快就能掌握了~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object源码解析]]></title>
    <url>%2F2018%2F12%2F03%2FObject%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[从今天起，正式开启jdk源码的学习，以前虽然也看过，但总是断断续续的没有系统的学习和坚持下来，现在下定决心要把这块骨头啃下来，哈哈。 java.long.Object是所有class的顶级父类，也是我们学习的源头。 首先我们来看一下Object的结构： 前两行就是静态代码块1234private static native void registerNatives(); static &#123; registerNatives(); &#125; 在加载类的时候会运行registerNatives()，将c/c++的代码加载到Java中的native方法，我们不需要太多关注。 1public final native Class&lt;?&gt; getClass(); 本地方法getClass()的作用是得到当前类运行时的类型。不能重写。1public native int hashCode(); hashCode()返回对象对应的哈希值，对于同一个对象调用时会返回相同的哈希值。123public boolean equals(Object obj) &#123; return (this == obj); &#125; equals()方法用于判断对象是否相等，比较的是两个对象的地址，如果你需要修改比较的方式，那么你需要重写equals方法和hashCode方法。 1protected native Object clone() throws CloneNotSupportedException; clone()方法用来返回一个对象的复制,和复制引用不同，会重新创建和分配内存空间：123456Object obj = new Object();Object obj1 = obj.clone();Object obj2 = obj;obj1 == obj;//falseobj2 == obj;//trueobj1 == obj2;//false 接下的是toString()方法，这个方法很常用，通常我们在自己的类中会重写这个方法。默认输出的是类名和哈希值。123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; notify()方法用于在多线程中唤醒等待的线程，notifyAll()的区别是唤醒所有正在等待当前对象的线程。12public final native void notify();public final native void notifyAll(); wait()方法用来暂时挂起当前线程，加入等待队列。这里要注意的是当timeout==0时，并不是等待0秒，而是一直等待，直到被唤醒。12345678910111213141516171819202122public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125;public final native void wait(long timeout) throws InterruptedException;public final void wait() throws InterruptedException &#123; wait(0); &#125; 最后一项是finalize()方法，这是一个回调函数，当gc即将回收当前对象时会调用这个方法，但这个时候并不会回收内存，在下一次回收时才会真正的释放内存空间。1protected void finalize() throws Throwable &#123; &#125; 下一节咱们学习String。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String源码解析]]></title>
    <url>%2F2018%2F12%2F03%2FString%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[接下来我们进行Sting的学习，这个类算是很常用的。 String继承了三个接口：1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;&#125; Serializable接口只是做一个标识，Comparable接口是赋予了String比较的能力，CharSequence接口则是对String内部的Char[]操作提供方便的参数。 12345/** The value is used for character storage. */ private final char value[];/** Cache the hash code for the string */ private int hash; // Default to 0 从这里可以看出String内部其实是char数组。 String有大量的构造方法，都是调用了其他工具类中的方法，比如Arrays.copyOf()、Arrays.copyOfRange()等等。 本来想一一介绍，但是看了一圈觉得并没有这个必要，我就挑几个比较特别的说说吧。12345678910public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; join()方法是在JDK1.8之后新加的，他的作用如下：1System.out.println(String.join(",","123","123"));//print: 123,123 这个函数可以方便我们进行数据展示的时候免于出现一连串的“”+””+…+””的蹩脚操作,也避免了删除最后一个字符的操作，他的内部实现其实是StringBuilder，即能够线程安全的展示数据。123456789101112131415161718192021222324252627282930313233public boolean equals(Object anObject) &#123; if (this == anObject) &#123;//比较地址 return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123;//循环比较value if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; equals本身没什么好说的，但是这个hashCode有点厉害，这个散列值为什么要这么计算请自行百度。 123456789101112131415161718192021222324//这里只说int型参，这个int是Unicode code,不是位置。public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125; &#125; 例如：12String str = "abc";System.out.println(str.indexOf(98));// 1 indexOf(String str)用来返回字符所在位置的下标。123public String substring(int beginIndex);public String substring(int beginIndex, int endIndex);public CharSequence subSequence(int beginIndex, int endIndex); substring方法用来分割字符串，最终实现都是重新new一个String：1new String(value, beginIndex, subLen) equalsIgnoreCase也比较有用，用于不区分大小写比较的情况123456public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); &#125; format是非常有用的一个方法，尤其你自己封装持久层时，简直是神器！支持的转换符有： 转换符 描述 转换符 描述 %s 字符串类型 %c 字符类型 %b 布尔类型 %d 十进制整数类型 %x 十六进制整数类型 %o 八进制整数类型 %f 浮点类型 %a 十六进制浮点类型 %e 指数类型 %g 通用浮点类型 %h 散列码类型 %% 百分比类型 %n 换行符 %tx 时间日期类型 123public static String format(String format, Object... args) &#123; return new Formatter().format(format, args).toString(); &#125; intern方法用来将String对象加入常量池并返回引用，在循环、递归有限集合中灰常有用！1public native String intern();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用软引用实现缓存机制]]></title>
    <url>%2F2018%2F12%2F03%2F%E5%88%A9%E7%94%A8%E8%BD%AF%E5%BC%95%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先，我们需要对java对象的4种引用有一个大概的认识。 java对象的引用包括强引用，软引用，弱引用，虚引用 顾名思义，他们表示对象的引用强度依次递减。 他们有什么作用？最重要的目的就是方便gc进行回收。我们都知道，java的一大特点就是开发者不用关心内存的使用，jvm会帮助我们自动回收无用的内存空间(对象),而哪些对象需要回收就是通过引用来作为一种判断依据。 一、四种引用1.强引用通常我们使用new关键字分配的对象都是强引用。例如：1Object obj = new Object(); 强引用的对象永远不会被回收。如果想要回收Object对象的话，将obj的引用置为空即可，gc会在合适的时机将它回收。12Object obj = new Object();obj = null; //Object准备被回收 2.软引用软引用有一个非常好的特性：当内存充足时，软引用的对象不会被回收，随时可以调用；当内存不足时，软引用的对象会被回收。 基于这个特性，很多高速缓存、页面缓存、图片缓存都是通过这个原理实现的。 获得一个软引用：123Object obj = new Object();SoftReference aSoftRef=new SoftReference(obj);obj = null; 软引用可以通过get()方法获得对象的强引用。1Object objNew = aSoftRef.get(); 3.弱引用弱引用就随意多了，是一个佛系青年，哈哈。不管内存的使用状态如何，什么时候进行内存回收就什么时候被清理掉。1WeakReference&lt;Object&gt; reference = new WeakReference&lt;Object&gt;(new Object()); 4.虚引用虚引用是四种引用中最弱的一种，只能和引用队列一起使用，可以用来监控对象是否被回收了。也就是说，你可以通过监控引用队列来让一个对象被回收之前做点什么。12ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;(); PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String("Hello World!"), queue); 二、利用软引用实现数据缓存首先，我们需要一个model类：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Car &#123; private double price; private String colour; private String name; private String id; public Car(double price, String colour) &#123; this.price = price; this.colour = colour; getDabaseData(); //假装去了数据库 - - &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public String getColour() &#123; return colour; &#125; public void setColour(String colour) &#123; this.colour = colour; &#125; public void getDabaseData()&#123; //一系列复杂操作，因为很复杂所以要做缓存，^_^ this.name = "数据库加载到名字"; this.id = "11111111111111"; &#125; @Override public String toString() &#123; return "Car&#123;" + "price=" + price + ", colour='" + colour + '\'' + ", name='" + name + '\'' + ", id='" + id + '\'' + '&#125;'; &#125;&#125; 下来是重头戏，缓存器的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class CarCache &#123; //缓存器 private static CarCache cache; //缓存队列 private HashMap&lt;String,CarSoftCache&gt; SoftRefs; //引用队列 private ReferenceQueue&lt;Car&gt; queue; private class CarSoftCache extends SoftReference&lt;Car&gt;&#123; String _key = null; public CarSoftCache(Car car,ReferenceQueue&lt;Car&gt; queue) &#123; super(car,queue); _key = car.getColour(); &#125; &#125; //缓存肯定得单例啦 private CarCache()&#123; SoftRefs = new HashMap&lt;String,CarSoftCache&gt;(); queue = new ReferenceQueue&lt;Car&gt;(); &#125; public static CarCache getInstance()&#123; if(cache==null)&#123; cache = new CarCache(); &#125; return cache; &#125; //将对象加入缓存队列 private void cacheCar(Car car)&#123; cleanCache(); CarSoftCache carSoftCache = new CarSoftCache(car,queue); SoftRefs.put(car.getColour(),carSoftCache); &#125; //主要方法：获取car的内容 public Car getCarByCache(String colour)&#123; Car car = null; if(SoftRefs.containsKey(colour))&#123; car = SoftRefs.get(colour).get(); System.out.println("找到缓存，读取car"); &#125; if(car==null)&#123; //没找到，进行复杂操作 car = new Car(60000,colour); System.out.println("无缓存，重新生成Car！"); this.cacheCar(car); &#125; return car; &#125; //清除指向car对象已经被清除的软引用 private void cleanCache()&#123; CarSoftCache carSoftCache; while((carSoftCache = (CarSoftCache)queue.poll())!=null)&#123; SoftRefs.remove(carSoftCache._key); &#125; &#125; //清除全部缓存 public void clearCache()&#123; cleanCache(); SoftRefs.clear(); System.gc(); System.runFinalization(); &#125;&#125; 下面是测试类：1234567891011121314public class test &#123; public static void main(String[] args) &#123; Car car = CarCache.getInstance().getCarByCache("white"); System.out.println("打印信息："+car); Car car2 = CarCache.getInstance().getCarByCache("white"); System.out.println("打印信息："+car2); Car car3 = CarCache.getInstance().getCarByCache("black"); System.out.println("打印信息："+car3); Car car4 = CarCache.getInstance().getCarByCache("white"); System.out.println("打印信息："+car4); &#125;&#125; 代码没有很复杂的地方，总体的思路就是获取对象时检查缓存队列，没有就存进去，有的话就拿出来。 下面是运行结果：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码解析]]></title>
    <url>%2F2018%2F11%2F29%2FThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ThreadLocal的源码简单易懂，很适合新手学习。现在我们一起来学习一下。 什么是ThreadLocal？顾名思义，ThreadLocal可以理解为一个线程本地变量池。所有线程都能往里面放东西并且互不干扰。也就是说，定义一个ThreadLocal后，每一个线程对它进行的操作都是线程隔离的，它通过将可变数据通过每个线程有的独立副本进行保存，从而实现线程封闭。 大致的实现思路是什么样的？Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程有一个自己的ThreadLocalMap。 ThreadLocalMap有自己的独立实现，可以简单地将它的key视作ThreadLocal，value为代码中放入的值（实际上key并不是ThreadLocal本身，而是它的一个弱引用）。 每个线程在往某个ThreadLocal里塞值的时候，都会往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。 几个重要的API 向当前线程中的ThreadLocalMap中存入数据 Public Set(T Value) 12345678910111213141516Public void set(Tvalue)&#123; Thread t = Thread.currentThread(); //获得当前线程 ThreadLocalMap map=getMap(t); //通过线程引用获得对应的ThreadLocalMap if(map!=null) //判断map是否存在，存数据或者新建map map.set(this,value); //这里是this，不是t else createMap(t,value);&#125;ThreadLocalMap getMap (Thread t)&#123; return t.threadLocals;&#125;Void createMap (Thread t,T firstValue)&#123; t.threadLocals = new ThreadLocalMap(this,firstValue);&#125; 获取当前进程存入的数据。 Public T get() 12345678910111213Public T get()&#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if(map != null)&#123; ThreadLocalMap.Entrye = map.getEntry(this); //通过this获取数据（其实是通过Hashcode） if(e != null)&#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); //返回null 进入初始化&#125; 为什么要用弱引用? 因为如果这里使用普通的key-valu形式来定义存储结构，实质上就会造成节点的生命周期与线程强绑定，只要线程没有销毁，那么节点在GC分析中一直处于可达状态，没办法被回收，而程序本身也无法判断是否可以清理节点。弱引用是Java中四档引用的第三档，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的键值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。（我们可以试着用软引用实现一个高速缓存，在我另一篇博文中会详细描述） 从上文的get()方法中我们可以看到，当调用时，会从当前线程中返回ThreadLocalMap，如果返回为null会调用setInitialValue()进行初始化操作： 123456789101112131415private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; ... protected T initialValue() &#123; return null; &#125; ... 我们可以看出，初始化操作就是判断线程是否含有ThreadLocalMap，如果有就将null插入其中占位，如果没有就创建： 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 所看出，正真实现线程线程本地变量池的其实是ThreadLocalMap，我们下面具体分析一下ThreadLocalMap。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328//ThreadLocalMap是一个静态内部类static class ThreadLocalMap &#123; //map中存放的结点信息，包括一个k(设为引用),Value //这里通过继承WeakReference使用弱引用作为键值巧妙的解决了内存释放问题，大师真的是厉害！ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; //初始容量，必须是2的次方 //为什么？这里有一个数学问题，和奇妙的0x61c88647有关，我讲不太明白，请自行百度 private static final int INITIAL_CAPACITY = 16; //结点数组 private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 /** * Set the resize threshold to maintain at worst a 2/3 load factor. */ //为什么是三分之二？请自行百度 private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; /** * Increment i modulo len. */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * Decrement i modulo len. */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; //敲黑板，请画重点 //初始化table，并通过&amp;运算计算出存放位置 //这里firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)我在后文单独解释一下 ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);//计算扩容的标准 &#125; //通过parentMap获得一个ThreadLocal子类ThreadLocalMap，想用这个方法，你得在自己的实现中重写childValue()方法 private ThreadLocalMap(ThreadLocalMap parentMap) &#123; Entry[] parentTable = parentMap.table; int len = parentTable.length; setThreshold(len); table = new Entry[len]; for (int j = 0; j &lt; len; j++) &#123; Entry e = parentTable[j]; if (e != null) &#123; @SuppressWarnings("unchecked") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); if (key != null) &#123; Object value = key.childValue(e.value); Entry c = new Entry(key, value); int h = key.threadLocalHashCode &amp; (len - 1); while (table[h] != null) h = nextIndex(h, len); table[h] = c; size++; &#125; &#125; &#125; &#125; //通过key计算地址并取出值 private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; //当找不到key对应的结点或者找到的结点对应的引用和key对应的引用不一致时调用 private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; //set新的数据，这里对找不到key的情况进行了处理（原来没处理的版本会造成内存泄漏），对脏数据进行了清除 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; //以前用完之后不进行remove会有内存泄漏的情况，但是现在加入了清理步骤，这个方法最后是否调用都不太重要了。 private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125; &#125; //清理脏数据，请自行研究，画个线型图更清除哦 private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; //从当前脏entry位置到返回的i位中间所有的脏entry private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** * Re-pack and/or re-size the table. First scan the entire * table removing stale entries. If this doesn't sufficiently * shrink the size of the table, double the table size. */ private void rehash() &#123; expungeStaleEntries(); // Use lower threshold for doubling to avoid hysteresis if (size &gt;= threshold - threshold / 4) resize(); &#125; //扩容 private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; //清理脏数据 private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125; &#125; &#125; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)这句的目的是计算位置，因为INITIAL_CAPACITY必须是2的次方所以INITIAL_CAPACITY - 1必定是一个形如0x00000111的数字，与前半部分的哈希值相&amp;就会得到一个极大概率不会冲突的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java内存模型和java对象模型]]></title>
    <url>%2F2018%2F11%2F29%2Fjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cjava%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一定要分清内存模型和对象模型。他们是完全不同的概念。 内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。 在前面一篇博文关于JVM内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。 OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。 当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。对象头中存在指向对应instanceKlass的指针。 这种组成对象的引用关系称为对象模型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK,JRE,JVM区别与联系]]></title>
    <url>%2F2018%2F11%2F29%2FJDK%2CJRE%2CJVM%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[很多初学java的同学总是分不清JDK、JRE和JVM。下面有请灵魂画手： 如图所示，简单明了，下面一一介绍。 JDKJava Development ToolKit(Java开发工具包)。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 JDK有以下三种版本： J2SE，standard edition，标准版，是我们通常用的一个版本 J2EE，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序 J2ME，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序 JREJava Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。 JVMJava Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。 为了加深印象，再补一张网图，侵删。找了好久，这张表达最清楚]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java学习</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机的内存组成以及堆内存介绍]]></title>
    <url>%2F2018%2F11%2F29%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E5%A0%86%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、Java内存组成：堆(Heap)和非堆(Non-heap)内存 官方说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。 可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 二、JVM内存区域模型 1.方法区(Method Area) 线程共享方法区也叫做“永久代”、“非堆”（应该只是非堆中的一项），它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize和-XX:MaxPermSize参数限制方法区的大小。 运行时常量池(Runtime Constant Pool)：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。（Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。） 2.虚拟机栈(Jvm Stack) 线程私有每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。 3.本地方法栈(Native Method Stack) 线程私有与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。 4.堆(Heap) 线程共享也叫做java堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建，我们常说的JVM优化也多从这里入手。 该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。 由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。 我在另一篇博文中会单独介绍各种收集算法。 新生代：程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。 老年代：用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建对象也有可能直接进入老年代，主要有两种情况： 大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。 大的数组对象，且数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。 5.程序计数器是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。 三、直接内存直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存(直接内存)，不会影响到堆内存的大小。这块内存被许多框架用来做高速缓存。 四、Java堆内存的10个要点 Java堆(Heap)比较重要，我们单独拿出来再说一说。 Java堆内存是操作系统分配给JVM的内存的一部分。 当我们创建对象时，它们存储在Java堆内存中。 为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。 你可以通过用JVM的命令行选项-Xms,-Xmx,-Xmn来调整Java堆空间的大小。不要忘了在大小后面加上M或者G来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。 你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。 你可以使用命令jmap来获得heap dump，用jhat来分析heap dump。 Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。 Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。 当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。 请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Android安卓65k问题]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%A7%A3%E5%86%B3Android%E5%AE%89%E5%8D%9365k%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给公司的老项目做开发可能都会见到这个问题： 出现这个问题的原因是由于在编译时，一个项目的class文件会被全部打包为一个classes.dex文件(玩过反编译的同学应该心有所感，哈哈)，它会为每个方法赋予一个id而这个id的范围在0~0xffff,所以一个app的方法数最多为65536个，超过这个数就会出现传说中的65k错误。 那如何解决呢？ Google官方已经给出了一个很好的解决方案，就是分割dex文件，这样就不会超过限制了(怎么感觉官方也是治标不治本呢)。 好了，下面进入正题。首先，我们需要引入Google提供的multiDex支持库，在build.gradle中加入：1234567891011121314//默认配置defaultConfig &#123; ... //开启多Dex支持 multiDexEnabled true ...&#125;...//支持库依赖dependencies &#123; ... compile 'com.android.support:multidex:1.0.1' ...&#125; 之后进入选择模式：12345678if(没有自己的Application类)&#123; 在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication： android:name="android.support.multidex.MultiDexApplication"&#125;else if(你的Application类已经继承其他类)&#123; 重写attachBaseContext()&#125;else&#123; 你的Application类继承MultiDexApplication&#125; 其实继承MultiDexApplication和直接重写attachBaseContext()没什么区别，MultiDexApplication内部也是重写了attachBaseContext()。 MultiDexApplication源码如下： 重写的内容：123456@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this);&#125; OK。问题解决了，现在你的项目已经支持dex分割了！ 最后，还是建议大家尽量别引入太多的外部框架和sdk，尽量精简程序。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓Android集成百度地图sdk]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%AE%89%E5%8D%93Android%E9%9B%86%E6%88%90%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEsdk%2F</url>
    <content type="text"><![CDATA[上周刚刚给公司的app集成了百度地图的sdk，所以现在把方法整理一下，希望对各位有帮助。 想要在app中使用百度地图有下边几个步骤：123注册百度开发者账号，创建应用获取id，指定路径下载对应功能的SDK包并导入自己的项目照猫画虎让程序跑起来 注册百度开发者账号 我记得以前还能用邮箱注册百度账号的，现在好像只能用手机了。 传送门1|传送门2(先进1号门注册百度账号，再进2号门注册百度开放平台开发者) 注册成功后去邮箱验证一下，点击申请密钥，进入配置界面。 根据你需要的功能勾选，不想挑的同学全选也行。这里获取SHA1比较麻烦，可以参考这篇博文 通过keytool工具可以快速获取开发版SHA1，你如果只是自己学习一下，那么开发版和发布版都填这个也可以。密钥默认是：android 灵魂打码 完成后点击提交，如下图所示成功，进入第二步。 下载sdk数据包百度提供了许多官方的例子，大家可以下载看看，基本上所有的基础功能都有演示。 压缩包里有4项，我们首先要将libs文件夹里的所有东西添加到自己程序的libs中，如下图。 再将上图中的BaiduNavi_AndroidSDK.zip解压,将jniLibs文件夹添加到我们自己项目的src/main下(这里的libs现在不加也没事，用到其中的方法再加即可)直接在src/main下创建jniLibs目录即可 项目配置接下来给app下的bulid.gradle加入：123456789101112sourceSets&#123; main&#123; jniLibs.srcDir 'libs' //说明so的路径为该libs路径，关联所有地图SDK的so文件 &#125;&#125;...dependencies&#123; compile files('libs/BaiduLBS_Android.jar')//添加jar依赖&#125;... 这段的意思是将libs下的os文件加载到src/main/jniLibs中。 在AndroidManifest中添加开发密钥、所需权限信息：1234567891011121314151617181920212223242526...//开发者信息&lt;application&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="开发者 key" /&gt; &lt;/application&gt;...//百度sdk所需权限&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;//获取设备网络状态，禁用后无法获取网络状态&lt;uses-permission android:name="android.permission.INTERNET"/&gt;//网络权限，当禁用后，无法进行检索等相关业务&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;//读取设备硬件信息，统计数据&lt;uses-permission android:name="com.android.launcher.permission.READ_SETTINGS" /&gt;//读取系统信息，包含系统版本等信息，用作统计&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;//获取设备的网络状态，鉴权所需网络代理&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;//允许sd卡写权限，需写入地图数据，禁用后无法显示地图&lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt;//获取统计数据&lt;uses-permission android:name="android.permission.CAMERA" /&gt; //使用步行AR导航，配置Camera权限... 安卓6.0以后有些权限不能直接申请了，得在代码里动态获取，请注意！ 编译通过后，配置阶段就完成了。 代码首先写布局文件，需要加入百度提供的MapView:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//layout...&lt;com.baidu.mapapi.map.MapView android:id="@+id/bmapView" android:layout_width="fill_parent" android:layout_height="fill_parent" android:clickable="true" /&gt;...//java...//DemoApplication.classpublic class DemoApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); //在使用SDK各组件之前初始化context信息，传入ApplicationContext SDKInitializer.initialize(this); //自4.3.0起，百度地图SDK所有接口均支持百度坐标和国测局坐标，用此方法设置您使用的坐标类型. //包括BD09LL和GCJ02两种坐标，默认是BD09LL坐标。 SDKInitializer.setCoordType(CoordType.BD09LL); &#125;&#125;...//MainActivity.class...public class MainActivity extends Activity &#123; private MapView mMapView = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取地图控件引用 mMapView = (MapView) findViewById(R.id.bmapView); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理 mMapView.onDestroy(); &#125; @Override protected void onResume() &#123; super.onResume(); //在activity执行onResume时执行mMapView. onResume ()，实现地图生命周期管理 mMapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); //在activity执行onPause时执行mMapView. onPause ()，实现地图生命周期管理 mMapView.onPause(); &#125; &#125;... DemoApplication最好在项目启动时就加载。 百度地图SDK接入已完成，具体功能请参照开发文档和官方demo，跑起来吧。 如果出现白屏请检查网络连接和开发者信息是否正确。 如果出现类似found libBaiduMapSDK_map_v5_2_1.so error这种错误，请检查你的sdk版本！不同组件的版本必须一致！！ 除此之外一些老项目可能会遇到“65k错误”：在我另一篇博文中单独解决这个问题。 如有错误请指正(右侧栏有联系方式)~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>百度地图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrollView中嵌套ListView的动态高度问题]]></title>
    <url>%2F2018%2F11%2F27%2FScrollView%E4%B8%AD%E5%B5%8C%E5%A5%97ListView%E7%9A%84%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题 昨天写代码时突然遇到一个问题，当ListView处于ScrollView中时，如果动态的给ListView添加数据的话，并不会显示多行，仅显示一行。 开始我以为是数据或者adapter的问题，检查了好多遍发现没问题，后来就一点点调试，发现ListView的高度是固定的，why？ 网上找到的答案是因为ListView和ScrollView的自动调节高度会冲突，解决的办法是自己去动态设置ListView要的高度。 具体代码123456789101112131415/**** yjhxqlistForLsjl 数据集合*/private void loadListViewForLsjl()&#123; adapter = new XlHistoryAdapter(this, yjhxqlistForLsjl);//初始化adapter adapter.enableCheck(false); adapter.enableDelete(false); mListViewForLsjl.setAdapter(adapter);//ListView设置adapter ListAdapter listAdapter = adapter;//获得监听 View item = listAdapter.getView(0, null, mListViewForLsjl); item.measure(0, 0);//设置测量模式 ViewGroup.LayoutParams params = mListViewForLsjl.getLayoutParams(); params.height = (yjhxqlistForLsjl.size()-1)*item.getMeasuredHeight()+item.getMeasuredHeight(); mListViewForLsjl.setLayoutParams(params);&#125; 可以看到其中有这么一段：123456789&#123; ... View item = listAdapter.getView(0, null, mListViewForLsjl); item.measure(0, 0); ViewGroup.LayoutParams params = mListViewForLsjl.getLayoutParams(); params.height = (yjhxqlistForLsjl.size()-1)*item.getMeasuredHeight()+item.getMeasuredHeight(); mListViewForLsjl.setLayoutParams(params); ...&#125; 这么写是为了获取ListView每一个Item的高度。刚开始获取高度我是这么写的：1mListViewForLsjl.getDividerHeight(); 之后发现不管多少数据，这个高度返回值都是1，可能是我没太理解getDividerHeight的意思。所以就采用了上面那种方式通过measure(关于measure的使用大家可以看看这篇博文，讲的浅显易懂)来动态的获取Item的高度。 问题是解决了，但以后还是要尽量避免ScrollView嵌套ListView的情况，毕竟解决方案不算完美，这种处理方式还是存在隐患的。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓实现切换后台监控]]></title>
    <url>%2F2018%2F11%2F26%2F%E5%AE%89%E5%8D%93%E5%AE%9E%E7%8E%B0%E5%88%87%E6%8D%A2%E5%90%8E%E5%8F%B0%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[上周四下午同事提了一个需求，想要监控app切换到后台和息屏的事件。原因是因为用户在使用app时大多数时候不会去主动关闭app，又因为我们的app和远程服务器有一个数据池的长连接，所以用户不主动退出就导致了连接数只增不减，最终down掉。所以他想在上述的两种事件中强制app退出。 其实我有点怀疑服务器传输堵塞可能不是这个问题造成的，连接池都会有超时熔断的操作，应该不会有连接不收回的情况。但是他既然有这个需求，那就先试着实现吧。 分析想要实现后台切换监控，第一个想到的就是从activity生命周期下手，对于Lifecycle大家应该都很熟悉了，从一个a到另一个a经历了几个过程呢？ 假设有两个页面 a 和 b。有些人觉得跳转过程是下面这样： 展示a界面：a.onCreat -&gt; a.onStart -&gt; a.onResume 跳转b界面：a.onPause -&gt; a.onStop -&gt; b.onCreat -&gt; b.onStart -&gt; b.onResume 其实跳转时的触发顺序是这样： 跳转b界面：a.onPause -&gt; b.onCreat -&gt; b.onStart -&gt; b.onResume -&gt; a.onStop 看到区别了吧？也就是说，一个界面在展示时总会触发onStart，但是触发onStop时却是在第二个页面触发onStart之后。 换句话说：只有在手机息屏和app切换到后台时onStart和onStop的触发数目才能相等。 由此咱们可以得出一种方案，通过计数来判断当前app的状态。 具体的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MyLifecycleHandler implements Application.ActivityLifecycleCallbacks &#123;//通过继承截获activity的周期方法 private static int appCount = 0;//计数器 private String TAG = "MyLifecycleHandler"; private final static int STOP_APP = 333;//标志 private final static long DELAY_TIME = 2*60*60*1000;//停止时间 单位：ms @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; @Override public void onActivityStarted(Activity activity) &#123; appCount++; Log.e(TAG,"切到前台"); uiHandler.removeMessages(STOP_APP); // 删除通知 &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; appCount--; if(appCount==0)&#123; Log.e(TAG,"切到后台"); uiHandler.sendEmptyMessageDelayed(STOP_APP,DELAY_TIME); &#125; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; &#125; private Handler uiHandler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case STOP_APP: Log.e(TAG,"杀死进程"); ActivityManager activityManager = (ActivityManager) ItcmorApplication.getContext().getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.AppTask&gt; appTaskList = activityManager.getAppTasks(); for (ActivityManager.AppTask appTask : appTaskList) &#123; appTask.finishAndRemoveTask(); &#125; System.exit(0); System.gc(); break; &#125; &#125; &#125;;&#125; 在监控到两种事件发生后，会发出一个通知，2小时后杀死进程。开始的时候这里直接调用System.exit(0)发现没什么用，后来明白这个exit只是退出虚拟机，页面并没有退出，后来参照了网上的做法获取activity栈，遍历移除。 算是完成这个需求了。但是这个退出有点暴力，如果各位朋友有更加优雅的退出方法请联系我哦~~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android小功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[共享变量可见性实现原理]]></title>
    <url>%2F2018%2F03%2F30%2F%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[多个线程共同使用的一个变量叫做共享变量。 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量的传递必须通过主内存完成。 java语言层面实现可见性的方式： synchronized volatile synchronized实现可见性synchronized最常见的一种理解是可以实现互斥锁，保证操作的原子性（同步）。同时，她也可以实现可见性。 JMM关于synchronize的两点规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中去。 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取共享变量的值（注意：加锁和解锁需要是同一把锁）上述操作就可以实现在线程解锁前对共享变量的修改可以在下次加锁时对其他线程可见。线程执行互斥代码的过程123456获得互斥锁清空工作内存从主内存拷贝变量的最新副本到工作内存执行代码将更新后的共享变量的值刷新到主内存释放互斥锁 补充知识重排序代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。共有三种： 编译器优化的重排序（编译器优化） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器优化）as-if-serial无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致。（java编译器、运行时和处理器都会保证java在单线程下遵循as-if-serial语义）synchronized实现可见性代码12345678910111213141516171819202122232425262728293031323334353637383940414243public class SynchronizedDemo &#123; //共享变量 private boolean ready = false; private int result = 0; private int number = 1; //写操作 public void write()&#123; ready = true; //1.1 number = 2; //1.2 &#125; //读操作 public void read()&#123; if(ready)&#123; //2.1 result = number*3; //2.2 &#125; System.out.println("result的值为：" + result); &#125; //内部线程类 private class ReadWriteThread extends Thread &#123; //根据构造方法中传入的flag参数，确定线程执行读操作还是写操作 private boolean flag; public ReadWriteThread(boolean flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; if(flag)&#123; //构造方法中传入true，执行写操作 write(); &#125;else&#123; //构造方法中传入false，执行读操作 read(); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo synDemo = new SynchronizedDemo(); //启动线程执行写操作 synDemo .new ReadWriteThread(true).start(); //启动线程执行读操作 synDemo.new ReadWriteThread(false).start(); &#125;&#125; 可见性分析不可见的原因： 线程的交叉执行 –&gt;原子性 重排序结合线程交叉执行 –&gt;原子性 共享变量更新后的值没有在工作内存和主内存间及时更新 –&gt;可见性synchronized解决方案加上synchronized 关键字后保证了执行代码的原子性，避免线程的交叉执行。12345678910//写操作 public synchronized void write()&#123; ready = true; //1.1 number = 2; //1.2 &#125; //读操作 public synchronized void read()&#123; if(ready)&#123; //2.1 result = number*3; //2.2 &#125; volatile实现可见性volatile关键字： 能够保证volatile变量的可见性 不能保证volatile变量复合操作的原子性volatile如何实现内存可见性深入来说：通过加入内存屏障和禁止重排序优化来实现的。 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令 store指令会强制刷新输入缓存，将改变的结果刷新到主内存中，同时能够禁止重排序的优化操作。 对volatile变量执行读操作时，会在读操作后加入一条load屏障指令load指令会强制刷新工作内存，从主内存中获取变量，同时能够禁止重排序的优化操作。 线程写volatile变量的过程： 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存线程读volatile变量的过程： 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 volatile不能保证原子性12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class VolatileDemo &#123; private int number = 0; public int getNumber()&#123; return this.number; &#125; public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.number++; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final VolatileDemo volDemo = new VolatileDemo(); for(int i = 0 ; i &lt; 500 ; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; volDemo.increase(); &#125; &#125;).start(); &#125; //如果还有子线程在运行，主线程就让出CPU资源， //直到所有的子线程都运行完了，主线程再继续往下执行 while(Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println("number : " + volDemo.getNumber()); &#125;&#125; 运行上面的代码会发现输出有时会出现接近500，但是不等于500的情况，这就是因为number++这步操作不属于原子操作造成的。 解决volatile不能保证自增操作原子性的问题 使用synchronized关键字 使用ReentrantLock（java.until.concurrent.locks包下，JDK1.5之后） 使用AtomicInterger（vava.util.concurrent.atomic包下，JDK1.5之后）关于synchronized的使用，上文已经说过，下面演示一下ReentrantLock的使用：123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class VolatileDemo &#123; private Lock lock = new ReentrantLock();//在这里实例化对象 private int number = 0; public int getNumber()&#123; return this.number; &#125; public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; lock.lock();//加锁 try &#123; this.number++; &#125; finally &#123; lock.unlock();//不如执行结果如何都要进行解锁 &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final VolatileDemo volDemo = new VolatileDemo(); for(int i = 0 ; i &lt; 500 ; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; volDemo.increase(); &#125; &#125;).start(); &#125; //如果还有子线程在运行，主线程就让出CPU资源， //直到所有的子线程都运行完了，主线程再继续往下执行 while(Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println("number : " + volDemo.getNumber()); &#125;&#125; volatile的适用场景在多线程中安全的适用volatile变量，必须同时满足两个条件： 对面变量的写入操作不依赖其当前值 不满足：number++、count=count*5等 满足：boolean变量、记录温度变化的变量等 该变量没有包含在具有其他变量的不定式中 不满足：low&lt;up synchronized和volatile的比较 volatile不需要加锁，比synchronize更轻量级，不会阻塞线程 从内存可见性的角度来讲，volatile的写操作相当于加锁，读操作相当于解锁 synchronized既能保证可见性又能保证原子性，而volatile只能保证可见性，不能保证原子性 补充：对64位（double、long）变量的读写有可能不是原子操作： Java内存模型(JMM)允许JVM将没有被volatile修饰的64位数据类型的读写操作划分成两次32位的读写操作来进行 导致的问题：有可能会出现读取到“半个变量”的情况解决方法：添加volatile关键字]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ITEM项目逻辑梳理之启动(一)]]></title>
    <url>%2F2018%2F03%2F10%2FITEM%E9%A1%B9%E7%9B%AE%E9%80%BB%E8%BE%91%E6%A2%B3%E7%90%86%E4%B9%8B%E5%90%AF%E5%8A%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 登陆控制无疑是我们这个项目启动后遇到的第一个问题，所有的初始化操作都要在登陆时进行，目前需要的初始化操作只有数据下载这一项，如果后期要添加初始化操作，我建议还是和数据下载放在同一操作层。 逻辑目前的登陆逻辑还是比较简单，后期肯定还会进行修改，本文将会持续跟进。具体如下图所示（如果加载缓慢请点击这里）： 重要的一点已经在图中标识，从“对比数据版本”开始，两种情况（首次和非首次登陆）一定要复用处理逻辑，尽量简洁代码量。最后下载失败时存的标识可以在进行数据相关操作时进行判断，如果存在下载失败状态，就立即提示用户先要更新本地数据。 如果有问题欢迎指正。]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ITEM项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN常用组件之SQLite]]></title>
    <url>%2F2018%2F03%2F07%2FRN%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E4%B9%8BSQLite%2F</url>
    <content type="text"><![CDATA[react-native-sqlite-storage 做一款完整的APP，数据存储自然是少不了的。当数据结构比较简单的时候AsyncStorage的键值对存储完全够用，但是面对一些复杂的数据结构我们就需要使用更为完善的持久方案。sqlite作为跨平台存储的优秀分子，哪里都少不了他的身影。 react-native-sqlite-storage是目前github上start最多的sqlite组件，也比较好用，下面介绍一下它的配置和基本使用。 安装配置（for Android）install1npm install --save react-native-sqlite-storage link// file: android/settings.gradle ... include &apos;:react-native-sqlite-storage&apos; project(&apos;:react-native-sqlite-storage&apos;).projectDir = new File(rootProject.projectDir,&apos;../node_modules/react-native-sqlite-storage/src/android&apos;) // file: android/app/build.gradle ... dependencies { ... compile project(&apos;:react-native-sqlite-storage&apos;) } Register12345678910111213141516import org.pgsqlite.SQLitePluginPackage;public class MainApplication extends Application implements ReactApplication &#123; ...... /** * A list of packages used by the app. If the app uses additional views * or modules besides the default ones, add more packages here. */ @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new SQLitePluginPackage(), // 在这里添加一行，别忘了import new MainReactPackage()); &#125;&#125; 经过上述步骤，组件就可以使用了。 具体使用方法全局设置通常要把他设为全局，这样在任何地方都可以操作数据库。设置方法如下： //在index.js里添加 123import SQLite from 'react-native-sqlite-storage';SQLite.DEBUG(true);SQLite.enablePromise(true); 打开/创建数据库首先需要一个数据库。123//打开数据库//location属性只对iOS有效,android是默认的SQLite.openDatabase(&#123;name: 'my.db', location: 'default'&#125;, successcb, errorcb); 更多参数请移步GitHub查看。 创建表12345678//操作API：transaction(func,[func=&gt;(error)&#123;&#125;],[func=&gt;&#123;&#125;])db.transaction(function(tx) &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS DemoTable (name, score)'); &#125;, function(error) &#123;//失败回调 console.log('Transaction ERROR: ' + error.message); &#125;, function() &#123;//成功回调 console.log('Populated database OK'); &#125;); 插入数据1234567db.transaction(function(tx) &#123; tx.executeSql('INSERT INTO DemoTable VALUES (?,?)', ['Alice', 101]); &#125;, function(error) &#123;//失败回调 console.log('Transaction ERROR: ' + error.message); &#125;, function() &#123;//成功回调 console.log('Populated database OK'); &#125;); 剩下的改查就不写了，可以看出来，就是在transaction()中调用executeSql()执行sql就行了。 特殊对于包含count()这类函数的语句，其结果处理要直接在executeSql()中标明。1234567db.transaction(function(tx) &#123; tx.executeSql('SELECT count(*) AS mycount FROM DemoTable', [], function(tx, rs) &#123; console.log('Record count (expected to be 2): ' + rs.rows.item(0).mycount); &#125;, function(tx, error) &#123; console.log('SELECT error: ' + error.message); &#125;); &#125;); 完整代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 产品类别表dao */import React, &#123; Component &#125; from 'react';import &#123; ToastAndroid,&#125; from 'react-native';import SQLiteStorage from 'react-native-sqlite-storage';SQLiteStorage .DEBUG(true);var database_name = "ITEM.db";//数据库文件var database_version = "1.0";//版本号var database_displayname = "ITEMSQLite";var database_size = -1;var db;export default class TBaseSblbDao extends Component &#123; componentWillUnmount()&#123; if(db)&#123; this._successCB('close'); db.close(); &#125;else &#123; console.log("SQLiteStorage not open"); &#125; &#125; open()&#123; db = SQLiteStorage.openDatabase( database_name, database_version, database_displayname, database_size, ()=&gt;&#123; this._successCB('open'); &#125;, (err)=&gt;&#123; this._errorCB('open',err); &#125;); return db; &#125; createTable()&#123; if (!db) &#123; this.open(); &#125; //创建产品类别表 db.transaction((tx)=&gt; &#123; tx.executeSql('CREATE TABLE IF NOT EXISTS T_BASE_SBLB(' + 'F_ID VARCHAR PRIMARY KEY AUTOINCREMENT,' + 'F_BM VARCHAR,'+ 'F_FBM VARCHAR,' + 'F_MC VARCHAR,' + 'F_TYPE VARCHAR,' + 'F_YRJ VARCHAR,' + 'F_PX VARCHAR)' , [], ()=&gt; &#123; this._successCB('executeSql'); &#125;, (err)=&gt; &#123; this._errorCB('executeSql', err); &#125;); &#125;, (err)=&gt; &#123;//所有的 transaction都应该有错误的回调方法 this._errorCB('transaction', err); &#125;, ()=&gt; &#123; this._successCB('transaction'); &#125;) &#125; deleteData()&#123;//清空数据 if (!db) &#123; this.open(); &#125; db.transaction((tx)=&gt;&#123; tx.executeSql('delete from user',[],()=&gt;&#123; &#125;); &#125;); &#125; dropTable()&#123;//删除表 db.transaction((tx)=&gt;&#123; tx.executeSql('drop table user',[],()=&gt;&#123; &#125;); &#125;,(err)=&gt;&#123; this._errorCB('transaction', err); &#125;,()=&gt;&#123; this._successCB('transaction'); &#125;); &#125; insertUserData(userData)&#123; let len = userData.length; if (!db) &#123; this.open(); &#125; this.createTable(); this.deleteData(); db.transaction((tx)=&gt;&#123; for(let i=0; i&lt;len; i++)&#123; //这部分是示例,照这个写就行，字段必须和传入的对应。 // var user = userData[i]; // let name= user.name; // let age = user.age; // let sex = user.sex; // let phone = user.phone; // let email = user.email; // let address = user.address; // let sql = "INSERT INTO user(name,age,sex,phone,email,address)"+ // "values(?,?,?,?,?,?)"; // tx.executeSql(sql,[name,age,sex,phone,email,address],()=&gt;&#123; // &#125;,(err)=&gt;&#123; // console.log(err); // &#125; // ); &#125; &#125;,(error)=&gt;&#123; this._errorCB('transaction', error); &#125;,()=&gt;&#123; this._successCB('transaction insert data'); &#125;); &#125; close()&#123; if(db)&#123; this._successCB('close'); db.close(); &#125;else &#123; console.log("SQLiteStorage not open"); &#125; db = null; &#125; _successCB(name)&#123; console.log("SQLiteStorage "+name+" success"); &#125; _errorCB(name, err)&#123; console.log("SQLiteStorage "+name); console.log(err); &#125; render()&#123; return null; &#125;&#125; 遇到的坑如果直接使用db.transaction，请设置SQLite.enablePromise(false),否则会报transaction is not a function全局设置时候global最好写成GLOBAL]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN常用组件系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN常用组件之二维码识别]]></title>
    <url>%2F2018%2F03%2F07%2FRN%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E4%B9%8B%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[react-native-barcodescanner 在项目中遇到了扫描二维码的需求,在网上找了一圈，发现这个组件很好用，目前已经加入到项目中了，表现还是可以的。下面说的这个组件的配置和基本使用。 安装配置install1npm i --save react-native-barcodescanner link//In android/settings.gradle ... include &apos;:react-native-barcodescanner&apos;, &apos;:app&apos; project(&apos;:react-native-barcodescanner&apos;).projectDir = new File(rootProject.projectDir,&apos;../node_modules/react-native-barcodescanner/android&apos;) //In android/app/build.gradle ... dependencies { ... compile project(&apos;:react-native-barcodescanner&apos;) } register12345678910111213import com.eguma.barcodescanner.BarcodeScannerPackage;...public class MainApplication extends Application implements ReactApplication &#123; ... @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new BarcodeScannerPackage()//在这里添加注册 ); &#125;&#125; 然后rebuild项目就可以使用组件了。 具体使用方法12345678910111213141516171819202122232425262728293031323334import React, &#123; AppRegistry, Component,&#125; from 'react-native';import BarcodeScanner from 'react-native-barcodescanner';class BarcodeScannerApp extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; torchMode: 'off', cameraType: 'back', &#125;; &#125; barcodeReceived(e) &#123; console.log('Barcode: ' + e.data); console.log('Type: ' + e.type); &#125; render() &#123; return ( &lt;BarcodeScanner onBarCodeRead=&#123;this.barcodeReceived&#125; style=&#123;&#123; flex: 1 &#125;&#125; torchMode=&#123;this.state.torchMode&#125; cameraType=&#123;this.state.cameraType&#125; /&gt; ); &#125;&#125;AppRegistry.registerComponent('BarcodeScannerApp', () =&gt; BarcodeScannerApp); ok，将上面代码复制到index.js跑起来试试吧~]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN常用组件系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative强烈推荐IDE]]></title>
    <url>%2F2018%2F03%2F06%2FReactNative%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90IDE%2F</url>
    <content type="text"><![CDATA[在RN开发过程中先后使用了好几个常见的IDE：IDEA、WS、Android studio等，最后觉得最好用的还是VScode。强烈推荐！她是一个非常轻量级的编辑器，而且有强大的插件支持，几乎你能想到的功能都可以找到对应的拓展插件，十分便捷，现在推荐一些开发RN必要的插件。 插件列表 Babel ES6/ES7 必要！ 检查ES6/ES7的语法，并且会高亮，很漂亮，必须安装（别告诉我，你还在用ES5）。 React Native Tools 必要！ 这个是微软出的开发工具，非常好用，让你摆脱命令行的束缚。 ESLint 代码检查工具，可以通过修改.eslintrc文件进行制定，团队开发有必要了解，有利于代码风格的统一。 Path Intellisense 路径补全插件，可以快速定位import的模块路径，必要！ Typing auto installer 自动根据package.json安装对应模块，再也不用npm install了 Beautify 代码美化插件，不是必须，但是真的不错。 GitLens/tortoise-svn版本控制git和svn，这个不多说了。 智能提示啰嗦一句，如果想要代码智能提示只需要在项目根目录执行：123npm install typings -gtypings install dt~react --savetypings install dt~react-native --save OK，现在重启VScode你会发现已经有代码提示了。]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发ReactNative项目遇到的问题总结]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%BC%80%E5%8F%91ReactNative%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目前公司正在着手RN的开发，毕竟都没用过也算是新手，这里记录一些开发过程中运用的组件及出现的错误，为后来人提供方便。 react-native-barcodescanner这个组件在我使用的扫描组件中算是比较稳定的，扫码界面打开时间也没有其他网友说的那么夸张。不过确定有一两秒的间隔。目前发现它不支持条码扫描（好像组件作者也没有想要长期更新下去的意思），所以准备用react-native-smart-barcode来替代，不过react-native-smart-barcode需要另一个splan组件进行支持，添加组件的时候会有一些麻烦。 ###]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
</search>
